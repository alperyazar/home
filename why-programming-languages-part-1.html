<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Why do we have programming languages in the first place? Part 1 | Alper Yazar</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Why do we have programming languages in the first place? Part 1" />
<meta name="author" content="Alper Yazar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="There are hundreds of computer programming languages. But why? Why do we keep inventing them?" />
<meta property="og:description" content="There are hundreds of computer programming languages. But why? Why do we keep inventing them?" />
<link rel="canonical" href="https://www.alperyazar.com/why-programming-languages-part-1.html" />
<meta property="og:url" content="https://www.alperyazar.com/why-programming-languages-part-1.html" />
<meta property="og:site_name" content="Alper Yazar" />
<meta property="og:image" content="https://www.alperyazar.com/assets/img/24/9.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-03-27T00:00:00+03:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://www.alperyazar.com/assets/img/24/9.jpg" />
<meta property="twitter:title" content="Why do we have programming languages in the first place? Part 1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alper Yazar"},"dateModified":"2025-05-09T19:32:32+03:00","datePublished":"2024-03-27T00:00:00+03:00","description":"There are hundreds of computer programming languages. But why? Why do we keep inventing them?","headline":"Why do we have programming languages in the first place? Part 1","image":"https://www.alperyazar.com/assets/img/24/9.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.alperyazar.com/why-programming-languages-part-1.html"},"url":"https://www.alperyazar.com/why-programming-languages-part-1.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
    <script src="/assets/js/lazysizes.min.js" async=""></script><link type="application/atom+xml" rel="alternate" href="https://www.alperyazar.com/feed.xml" title="Alper Yazar" /><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="/favicon.ico"><!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-S3B80PC7FC"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-S3B80PC7FC');
    </script>

    

    
    <!-- Adsense -->
    <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4580059638713287"
    crossorigin="anonymous"></script> -->
    <link rel="me" href="https://mastodon.social/@ayazar">
  </head>
<body><header class="site-header" role="banner">

    <div class="wrapper"><a class="site-title" rel="author" href="/">Alper Yazar</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>

          <div class="trigger"><a class="page-link" href="/blog/">📝 Blog</a><a class="page-link" href="/search.html">🔍 Search</a><!-- <a class="page-link" href="https://ayazar.dev" target="_blank">🗂️ Notes</a> -->
            <a rel="me" class="page-link" href="https://www.linkedin.com/in/alperyazar" target="_blank">💼 LinkedIn</a>
            <a rel="me" class="page-link" href="https://www.youtube.com/@ayazar" target="_blank">🎬 YouTube</a>
          </div>
        </nav></div>
  </header>

  

<div id="son_yazi_banner" style="
background: linear-gradient(to right, rgba(250, 191, 200, 0.3), rgba(23, 86, 169, 0.2));
color: rgb(52, 55, 67);
text-align: center;
padding: 15px;
border-radius: 10px;
border: 0px dashed rgba(250, 191, 200, 0.5);
box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.1);
margin: 10px 0px 10px 0px;">🚀 The latest blog post:&nbsp;<a href="/fpga-git-cicd-devops.html" style="font-weight: bold;"><span style="font-weight: bold;">FPGA, Git, DevOps, CI/CD</span></a>&nbsp;🇹🇷</div>

  <div id="progressBar" class="progress-bar"></div>

  <script>
    // Listen for scroll events on the window
window.onscroll = function() {
    // Call the function to update the progress bar
    updateProgressBar();
};

function updateProgressBar() {
    // Get the total height of the page
    var scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    // Get the current scroll position
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    // Calculate the scroll percentage
    var scrollPercentage = (scrollTop / scrollHeight) * 100;
    // Update the width of the progress bar
    document.getElementById("progressBar").style.width = scrollPercentage + "%";
}
  </script>

<a href='/support.html' class="floating-icon-heart" width="48" target="_blank"><img src='/assets/img/icons8-heart-64.png' alt="❤️ Support/Destek" title="❤️ Support/Destek"></a>

<div id="special-flag">
  <a id="special-flag-link" href="#" target="_blank" title="">
    <img src='/assets/img/bayrak.png' alt="Türk Bayrağı">
  </a>
</div>

<script>
  /*
   * Ref: https://www.pau.edu.tr/tks/tr/sayfa/milli-ve-dini-bayramlar
   * Ref: https://www.mevzuat.gov.tr/mevzuat?MevzuatNo=859034&MevzuatTur=2&MevzuatTertip=5
   * Ref: https://www.eserotomatikbayrak.com/bayrak-asilacak-tarihler.pdf
   * Net bir şey bulmak zor :(
  */
  const specialDays = [
    ["03-18", "https://tr.wikipedia.org/wiki/18_Mart_%C3%87anakkale_Zaferi_ve_%C5%9Eehitleri_Anma_G%C3%BCn%C3%BC", "Çanakkale Zaferi ve Şehitleri Anma Günü"],
    ["04-23", "https://tr.wikipedia.org/wiki/23_Nisan_Ulusal_Egemenlik_ve_%C3%87ocuk_Bayram%C4%B1", "Ulusal Egemenlik ve Çocuk Bayramı"],
    ["05-01", "https://tr.wikipedia.org/wiki/1_May%C4%B1s_%C4%B0%C5%9F%C3%A7i_Bayram%C4%B1", "Emek ve Dayanışma Günü"],
    ["05-19", "https://tr.wikipedia.org/wiki/19_May%C4%B1s_Atat%C3%BCrk%27%C3%BC_Anma,_Gen%C3%A7lik_ve_Spor_Bayram%C4%B1", "Atatürk'ü Anma, Gençlik ve Spor Bayramı"],
    ["07-15", "https://tr.wikipedia.org/wiki/Demokrasi_ve_Mill%C3%AE_Birlik_G%C3%BCn%C3%BC", "Demokrasi ve Millî Birlik Günü"],
    ["08-30", "https://tr.wikipedia.org/wiki/30_A%C4%9Fustos_Zafer_Bayram%C4%B1", "Zafer Bayramı"],
    ["10-29", "https://tr.wikipedia.org/wiki/29_Ekim_Cumhuriyet_Bayram%C4%B1", "Cumhuriyet Bayramı"],
    ["11-10", "https://tr.wikipedia.org/wiki/10_Kas%C4%B1m_Atat%C3%BCrk%27%C3%BC_anma_g%C3%BCn%C3%BC_ve_Atat%C3%BCrk_haftas%C4%B1", "Atatürk'ü Anma Günü"]
  ];

  const today = new Date();
  const todayKey = `${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

  const match = specialDays.find(([key]) => key === todayKey);
  if (match) {
    const [_, url, tooltip] = match;
    const flagDiv = document.getElementById("special-flag");
    const flagLink = document.getElementById("special-flag-link");
    flagLink.href = url;
    flagLink.title = tooltip;
    flagDiv.style.display = "block";
  }
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Why do we have programming languages in the first place? Part 1</h1>
    <p class="post-meta"><time class="dt-published" datetime="2024-03-27T00:00:00+03:00" itemprop="datePublished">
        2024-03-27
      </time>~<time class="dt-modified" datetime="2025-05-09T19:32:32+03:00" itemprop="dateModified">
        2025-05-09
      </time>• 🇬🇧<span> • 24-9</span>
      </p>
  </header><div style="background: #eeeeff; border-radius: 2px; margin: 2px;"><center><p><span data-nosnippet>🔤 <small><a rel=”nofollow” href="https://www-alperyazar-com.translate.goog/why-programming-languages-part-1.html?_x_tr_sl=auto&_x_tr_tl=tr">Google Translate ile çevir</a></small>  🔤</span></p></center></div><div class="post-content e-content" itemprop="articleBody"><center>
    <p>
    <a class="post-link" href="/why-programming-languages-part-1.html"><img alt="Teaser" data-srcset="/assets/img/24/9.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9.jpg" data-srcset="/assets/img/24/9.jpg"  srcset="/assets/lazyload.png" style="border-radius: 10px;" class="lazyload"></a>
    </p>
    </center><p><i>There are hundreds of computer programming languages. But why? Why do we keep inventing them?</i></p>
    <hr><div style="background: #ffec99; border-radius: 2px; margin: 2px;"><center><p><span data-nosnippet>ℹ️ <small><a href="/disclaimer.html">Disclaimer</a></small> ℹ️</span></p></center></div><hr>
    <p>In this two-part mini-series, I will share my understanding and thoughts on
programming languages and computers in general. This first part will cover:</p>

<ul>
  <li>Types of processors</li>
  <li>The language bridging us and processors</li>
  <li>Key terms such as <strong>instruction set, instruction set architecture (ISA), machine
code, assembly language</strong></li>
</ul>

<p>We have at least <strong>500 programming languages in existence today.</strong> <sup id="fnref:4f"><a href="#fn:4f" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> But why
do we continue to invent them? Let’s talk! But first:</p>

<h2 id="why-do-computers-exist-in-the-first-place-">Why do computers exist in the first place? 💻</h2>

<p>Computers are expensive and require extensive engineering effort to develop. As
individuals, we invest hundreds of dollars 💲 each year in our personal computers,
including laptops, gaming consoles, mobile phones, desktops, and more. <strong>But why?</strong>
They must serve a purpose, correct? Indeed. Actually, each of these computers
addresses a specific problem we encounter. Computers can perform complex
mathematical computations, facilitate aircraft landings, entertain us, enable
over-the-air communication, and even contribute to the discovery of planets in
space! But how do they accomplish these tasks? <strong>What is the magic behind their
functionality?</strong></p>

<hr />

<p><img data-srcset="/assets/img/24/9-eniac.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-eniac.jpg" alt="ENIAC" class="centered lazyload" /></p>

<p class="text-align-center"><a href="https://en.wikipedia.org/wiki/ENIAC">ENIAC</a>, <strong>E</strong>lectronic <strong>N</strong>umerical
<strong>I</strong>ntegrator <strong>a</strong>nd <strong>C</strong>omputer, <strong>designed in 1945</strong> to solve
military-related problems, stands as one of the earliest computers (The whole
thing in the room is a single computer. Power consumption was <strong>higher than 150
kW</strong>). With a cost exceeding <strong>6 million US Dollars</strong> (adjusted for inflation),
it was capable of performing only <strong>5000 operations per second</strong>—a figure that
may seem modest compared to today’s standards but still exceeded human capacity
at the time.
<a href="https://commons.wikimedia.org/wiki/File:Classic_shot_of_the_ENIAC.jpg">Photo</a></p>

<hr />

<p>The magic lies in the ability to <strong>leverage information</strong> to accomplish these
tasks. Computers possess <strong>memory</strong> to <strong>store</strong> information and fast
<strong>communication</strong> links to facilitate the exchange of data. Ultimately, the crux
of computer functionality revolves around the generation and processing of
information.</p>

<blockquote>
  <p>Computers are incredible inventions created by smart people, but there’s no
actual magic involved. They work because they’ve been carefully designed and
engineered. If you want to experience something truly magical, consider
exploring the wonders of nature through the study of natural sciences. 🪄</p>
</blockquote>

<p>Nearly all problems solved by computers boil down to mathematical problems.
Computers excel with numbers, capable of executing algorithms on data orders of
magnitude faster than a human could. <strong>But how do they achieve this?</strong></p>

<h2 id="processors">Processors</h2>

<p>Processors serve as the heart ❤️ of computers (or brains 🧠, whatever organ you
choose). A processor is an electronic hardware component capable of manipulating
numbers at an incredibly high speed. While processors themselves can’t store
data, they “process” (hence their name) the stored data, such as in RAM, and
generate new data. They can achieve this at rates of billions of operations per
second. Examples of processors include the <strong>CPU</strong> (Central <strong>Process</strong>ing
Unit), <strong>GPU</strong> (Graphics <strong>Process</strong>ing Unit), and <strong>TPU</strong> (Tensor
<strong>Process</strong>ing Unit).</p>

<p><strong>CPU</strong>s, or <strong>Central Processing Units</strong>, are general-purpose processors found in
nearly all computers and many electronic devices. They are designed to handle a
wide range of tasks, such as text editing, web surfing, and number crunching,
typical of personal computers. Unlike specialized processors optimized for
specific tasks, CPUs are not tailored to excel in any single function but rather
are engineered to efficiently handle a variety of tasks.</p>

<p><img data-srcset="/assets/img/24/9-6502.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-6502.jpg" alt="6502" class="centered lazyload" /></p>

<p class="text-align-center">The <a href="https://en.wikipedia.org/wiki/MOS_Technology_6502">MOS Technology 6502</a> is
a highly renowned microprocessor introduced in 1975, widely utilized in numerous
microcomputers and video game consoles during the 1980s era. Capable of
executing 1-2 million operations per second, it represented a significant leap
in computing power compared to the 5000 operations per second capability of the
ENIAC, which was designed in 1945. Despite its enhanced performance, the price
of the 6502 remains relatively affordable, around $150 today when adjusted for
inflation (originally $25 in 1975).
<a href="https://en.wikipedia.org/wiki/File:MOS_6502AD_4585_top.jpg">Photo</a></p>

<hr />

<p><strong>GPU</strong>s, or <strong>Graphics Processing Units</strong>, differ from CPUs. While they are also
processors, their internal architecture is specifically optimized to efficiently
handle calculations required for graphical tasks. GPUs excel in processing
graphical data by leveraging parallel computing, utilizing thousands of multiple
processors designed to execute tasks simultaneously. Because neural network
problems share a similar parallel nature to graphics tasks, GPUs are
increasingly being utilized not only for graphical applications but also for
solving AI problems. Nonetheless, they remain processors at their core.</p>

<p><img data-srcset="/assets/img/24/9-rtx-4090.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-rtx-4090.jpg" alt="RTX 4090" class="centered lazyload" /></p>

<p class="text-align-center">The modern GPU card, Nvidia’s RTX 4090, released in 2022 for approximately
$1600, boasts impressive capabilities. With its <a href="https://en.wikipedia.org/wiki/GeForce_40_series">GeForce 40 series
GPU</a>, it can perform 73,000
billion single-precision floating-point operations per second while operating
under 450W. <a href="https://en.wikipedia.org/wiki/File:NVIDIA_RTX_4090.jpg">Photo</a></p>

<hr />

<p><strong>TPU</strong>s, or <strong>Tensor Processing Units</strong>, are custom processors specifically
designed for neural network applications. Developed by Google,
<a href="https://en.wikipedia.org/wiki/Tensor_Processing_Unit">TPU</a>s are engineered to
perform the mathematical operations necessary for neural network tasks more
efficiently than GPUs. Unlike GPUs, TPUs are tailored solely for optimizing the
performance of neural network computations.</p>

<p><img data-srcset="/assets/img/24/9-TPUv3.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-TPUv3.jpg" alt="TPU" class="centered lazyload" /></p>

<p class="text-align-center">Photo of TPUv3 processors. We can’t see them directly because they are under
heatsinks. TPUv4 announced in 2021 is capable of doing 275,000 billion
operations per second while operating under 170W.
<a href="https://en.wikipedia.org/wiki/File:Tensor_Processing_Unit_3.0.jpg">Photo</a></p>

<hr />

<p><strong>Microcontroller</strong>s, MCUs, present in nearly all electronic devices, also
contain processors within them. In general, these processors are specifically
designed to handle tasks that are not computationally intensive. However,
certain microcontrollers are engineered to execute tasks with minimal power
consumption, enabling devices to operate for years a single battery.</p>

<p><img data-srcset="/assets/img/24/9-PIC18F8720.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-PIC18F8720.jpg" alt="PIC" class="centered lazyload" /></p>

<p class="text-align-center">A <a href="https://en.wikipedia.org/wiki/PIC_microcontrollers">PIC</a> microcontroller from
<a href="https://en.wikipedia.org/wiki/Microchip_Technology">Microchip Technology</a>.
<a href="https://commons.wikimedia.org/wiki/File:PIC18F8720.jpg">Photo</a></p>

<hr />

<p>As evident, there exist numerous types of processors, beyond the examples
provided, each tailored for specific purposes. Various companies are involved in
the design and manufacturing of these processors. For instance, Intel and AMD
are renowned for their CPUs, while Nvidia specializes in GPUs.</p>

<p><strong>However, regardless of the type or manufacturer, all these processors
fundamentally operate in a similar manner. The process of utilizing or
programming them has remained essentially the same for decades, spanning across
a wide range of processors.</strong></p>

<h2 id="talking-with-processors">Talking with Processors</h2>

<p>Now that we’ve grasped the importance of the processor in a computer system,
whether it’s a CPU, GPU, TPU, or any other variant, let’s delve into its primary
functions. Broadly speaking, a processor performs two types of tasks:
<strong>arithmetic operations</strong>, which involve mathematical computations like
addition, multiplication, and division, and <strong>logical operations</strong>, which entail
making decisions based on conditions—for instance, determining if number <code class="language-plaintext highlighter-rouge">A</code> is
greater than <code class="language-plaintext highlighter-rouge">B</code> and taking appropriate actions accordingly. But how exactly do
we communicate with a processor to get our tasks done?</p>

<p>Let’s imagine that I’ve purchased an <a href="https://www.amd.com/en/products/apu/amd-ryzen-7-8700g">AMD Ryzen 7
8700G</a> CPU from a
computer store. This CPU, designed by AMD and released in early 2024, is capable
of performing billions of operations per second, which is quite impressive. Now,
let’s say I simply want to add two numbers together and obtain the result. How
can I communicate this task to the CPU? How do I tell the CPU, <strong>“Hey, here are
two numbers. Please add them together and return the result to me?”</strong></p>

<p><img data-srcset="/assets/img/24/9-amd-ryzen-7-8700g.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-amd-ryzen-7-8700g.jpg" alt="AMD Ryzen 7 8700G" class="centered lazyload" /></p>

<p class="text-align-center">AMD Ryzen 7 8700G. Photo by <a href="https://www.tomshardware.com/pc-components/cpus/amd-ryzen-7-8700g-cpu-review">Tom’s
Hardware.</a></p>

<hr />

<p>As we’ve observed, there is a wide array of processors available today, each
tailored to different applications with various optimizations such as power
consumption and speed. Over the past 80 years, these processors have undergone
dramatic changes in size, performance, and price. Comparing the computational
power of a modern basic cell phone to that of the <a href="https://en.wikipedia.org/wiki/Apollo_Guidance_Computer">Apollo Guidance
Computer</a>, for example,
would be practically meaningless. However, with all these historical
advancements and variations, one fundamental aspect remains nearly unchanged:
<strong>the basic operational principle of a processor.</strong></p>

<p>Processors are essentially devices designed to execute tasks, functioning as an
<em>execution engine</em> of sorts. Regardless of their processing power, a processor
simply carries out the instructions it is given—no more, no less. We provide a
list of commands, or <strong>instruction</strong>s, to a processor, and it executes them one
by one. Each instruction tells the processor precisely what action to take. A
computer program essentially consists of an ordered set of instructions for the
processor to follow. These instructions are stored in memory, typically RAM, and
can be accessed by the processor. The processor then begins executing these
instructions sequentially, from start to finish. Below is an illustration of how
a program appears in memory:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Instruction 001: Do this
Instruction 002: Do that
Instruction 003: If A &lt; N, do this otherwise do that
...
Instruction 875: Do this
Instruction 876: End
</code></pre></div></div>

<p>As you may have noticed, for a processor to be capable of performing useful
tasks, it needs to support more than just one instruction. A processor that can
only add two numbers together without any additional functionality wouldn’t be
very practical, would it? Therefore, processors are designed to support a wide
range of instructions, and the set of instructions supported by a processor is
called its <strong>Instruction Set</strong>.</p>

<p>If you’re interested in this topic, you may have come across two terms: <strong>RISC</strong>
and <strong>CISC</strong>. In these terms, <code class="language-plaintext highlighter-rouge">IS</code> in the middle stands for <strong>I</strong>nstruction
<strong>S</strong>et. RISC stands for <strong>R</strong>educed <strong>I</strong>nstruction <strong>S</strong>et <strong>C</strong>omputer, while
CISC stands for <strong>C</strong>omplex <strong>I</strong>nstruction <strong>S</strong>et <strong>C</strong>omputer. Anyway, let’s
proceed with our exploration: talking with processors.</p>

<hr />

<p>Let’s delve into instructions in more detail. As mentioned earlier, instructions
are stored in memory and are accessible by the processor. Computers operate
using numbers, <a href="https://en.wikipedia.org/wiki/Binary_number">binary numbers</a>
most of the time, which consist of 0s and 1s. This applies to both memory and
processors. Each instruction communicates to the processor what action to take.
To efficiently store these commands in memory, each command is encoded with a
number. For instance, for a specific processor, reading a “01” from memory might
indicate an addition operation, “10” for subtraction, “11” for comparison, and so
on. In a moment, I’ll provide a real-life example from a processor to illustrate
this further. Stay tuned!</p>

<h3 id="example-pic16f84">Example: PIC16F84</h3>

<p>Let’s examine a real-life example. To maintain simplicity and focus on the topic
without getting distracted by advanced features implemented by a processor, I’ve
chosen an old microcontroller from Microchip Technology: the
<a href="https://www.microchip.com/en-us/product/pic16f84">PIC16F84</a>. This
microcontroller holds a special significance for me because it was the first
microcontroller I programmed when I began experimenting with hobby electronics
in high school.</p>

<p><img data-srcset="/assets/img/24/9-PIC16C84.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-PIC16C84.jpg" alt="PIC 16C84" class="centered lazyload" /></p>

<p class="text-align-center"><a href="https://en.wikipedia.org/wiki/PIC16x84">PIC16C84</a> is an older version of
PIC16F84. It was introduced in 1993.
<a href="https://commons.wikimedia.org/wiki/File:Two_Microchip_PIC16C84_chips.jpg">Photo</a></p>

<p>The datasheet of the PIC16F84 microcontroller is available on the
<a href="https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/30430D.pdf">manufacturer’s
website.</a>
Let’s navigate to the “Instruction Set Summary” section, located on page 55, to
gain insight into the instructions supported by this microcontroller.</p>

<p>This microcontroller consists of a CPU and an internal memory to store
instructions that will be executed sequentially by the CPU. However, the memory
structure is somewhat unusual because each row has a width of <strong>14 bits.</strong>
Typically, we are familiar with memories with widths that are multiples of 8
bits, such as 8, 16, or 32 bits. Nevertheless, there’s nothing inherently wrong
with having a memory width of 14 bits. We can visualize the memory as follows:</p>

<p><img data-srcset="/assets/img/24/9-PIC-memory.png" srcset="/assets/lazyload.png" src="/assets/img/24/9-PIC-memory.png" alt="PIC 16F84 Memory" class="centered lazyload" /></p>

<p class="text-align-center">Note that each row is filled with random 14-bit data just for illustrative purposes.</p>

<p>The internal program memory of the PIC16F84 is capable of holding 1024
instructions, each with a width of 14 bits.</p>

<p>On the same page, page 55, the instruction format is illustrated as follows:</p>

<p><img data-srcset="/assets/img/24/9-figure-9-1.png" srcset="/assets/lazyload.png" src="/assets/img/24/9-figure-9-1.png" alt="PIC16F84 Instruction Format" class="centered lazyload" /></p>

<p class="text-align-center">PIC16F84 Instruction Format</p>

<p>The first notable aspect is that this particular processor can interpret four
different instruction formats. Depending on the instruction category, each bit
in the 14-bit word carries a distinct significance. Every instruction includes a
common field known as <strong>OPCODE</strong>. All instructions supported by the processor are
assigned a unique number, referred to as the OPCODE. The remaining bits may be
interpreted differently by the processor based on the instruction, i.e., the
OPCODE.</p>

<p>On the next page in the datasheet, Table 9-2 lists all instructions, i.e., the
<strong>Instruction Set</strong>, along with their corresponding OPCODEs.</p>

<p><img data-srcset="/assets/img/24/9-table-9-2.png" srcset="/assets/lazyload.png" src="/assets/img/24/9-table-9-2.png" alt="PIC16F84 All Instructions" class="centered lazyload" /></p>

<p class="text-align-center">All instructions supported by PIC16F84</p>

<p>The PIC16F84 supports 35 distinct instructions. For humans, it is not practical
to memorize the bit patterns for all instructions. Therefore, each instruction
is assigned a <em>nickname</em> called a <strong>mnemonic.</strong> In this context, a mnemonic is
the term for the instruction name.</p>

<p>Some instructions, like <code class="language-plaintext highlighter-rouge">SLEEP</code>, don’t require any additional information from
the programmer. However, many instructions do need additional information to
operate. For instance, <code class="language-plaintext highlighter-rouge">CLRF</code> is used to fill a memory location with all 0s.
However, we have to provide the address of the location, otherwise <code class="language-plaintext highlighter-rouge">CLRF</code> won’t
know which memory location to clear. These additional parameters given with
instruction names are called <strong>operands</strong> in this context.</p>

<p>To delve deeper into the subject, let’s analyze an instruction thoroughly. Let’s
consider the <code class="language-plaintext highlighter-rouge">ANDLW</code> instruction. The detailed explanation is provided on page 57
of the datasheet as follows:</p>

<p><img data-srcset="/assets/img/24/9-andlw.png" srcset="/assets/lazyload.png" src="/assets/img/24/9-andlw.png" alt="ANDLW" class="centered lazyload" /></p>

<p>The first 6-bit value, <code class="language-plaintext highlighter-rouge">111001</code>, represents the OPCODE of this instruction. The
remaining 8 bits constitute the single operand required for the instruction.
Essentially, the <code class="language-plaintext highlighter-rouge">ANDLW</code> instruction performs a logical AND operation between
the content of the <code class="language-plaintext highlighter-rouge">W</code> register and the constant value encoded in the 8-bit
operand field. The result is then stored back into the <code class="language-plaintext highlighter-rouge">W</code> register.</p>

<p>ℹ Note that the <code class="language-plaintext highlighter-rouge">W</code> register is a special storage area found in the processor of
this microcontroller. This name is specific to this processor, and other
processors may have a different number of registers with different names.
Therefore, don’t worry too much about this naming convention—it’s unique to this
particular microcontroller.</p>

<p>The processor in the microcontroller essentially reads 14-bit wide instructions
from the program memory, row by row. Let’s say the processor reads the value
<code class="language-plaintext highlighter-rouge">11100100010010</code>. When we split this value, we have <code class="language-plaintext highlighter-rouge">111001</code> concatenated with
<code class="language-plaintext highlighter-rouge">00010010</code>. This represents the <code class="language-plaintext highlighter-rouge">ANDLW</code> instruction with an operand value of
0x12 (in hexadecimal, 18 in decimal). When the processor reads this particular
14-bit value, it performs a logical AND operation between the value stored in
the <code class="language-plaintext highlighter-rouge">W</code> register and 0x12, and then writes the result back to the <code class="language-plaintext highlighter-rouge">W</code> register.</p>

<p>The program memory could be like this:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;14-bit wide instruction&gt;
&lt;14-bit wide instruction&gt;
...
11100100010010 -&gt; ANDLW 0x12
...
&lt;14-bit wide instruction&gt;
</code></pre></div></div>

<p>If you continue reading the remaining part of the datasheet, you’ll notice that
each instruction is explained in detail. Similarly, all processors have similar
documents that explain each instruction and its effects on the state of the
processor (such as registers).</p>

<p>The set of instructions + the architecture that behaves according to those
instructions is referred to as the <strong>Instruction Set Architecture (ISA)</strong>.</p>

<hr />

<p>In summary, processors only understand instructions, often accompanied by
operands. To achieve meaningful outcomes, programmers must provide instructions
in a logical order. Processors lack awareness of the tasks they are performing
(such as calculating the Fibonacci Sequence); it is the programmer’s
responsibility to ensure that the set of instructions executed by the processor
yields a meaningful result. This result may be stored in main memory, such as
RAM. Importantly, <strong>processors do not understand programming languages like
JavaScript, Python, or C.</strong> They can only execute instructions stored in memory,
supported by their own ISA, one by one, without deviation.</p>

<h2 id="isa-the-contract">ISA: The Contract</h2>

<p>Commonly, ISA is defined as the contract between software and hardware.
Considering ISA as an agreement between hardware and software people is a very
apt representation. Let’s explore why.</p>

<p>In the previous example, we explored the ISA implemented by Microchip company in
the PIC16F84 microcontroller. However, we didn’t delve into the internals of the
processor. We don’t know how Microchip uses flip-flops and transistors to build
the processor. We don’t know how the logical AND operation is implemented at the
transistor level, and <strong>we don’t need to!</strong> The only thing we need to utilize a
processor designed by a company is the details explained in the ISA.</p>

<p>The concept of <strong>ISA is similar to API (Application Programming Interface)</strong> in the
software world. As programmers who are willing to utilize existing processors,
rather than design them, we only need to know how to use them, not their
internal structure. As long as processor manufacturers adhere to the rules
defined in the corresponding ISA, they are free to design whatever circuit they
like, and programmers won’t notice any difference.</p>

<p><img data-srcset="/assets/img/24/9-isa.png" srcset="/assets/lazyload.png" src="/assets/img/24/9-isa.png" alt="ISA" class="centered lazyload" /></p>

<p class="text-align-center">ISA is the contract between software and hardware. Taken from <a href="https://people.inf.ethz.ch/omutlu/">Onur
Mutlu</a>’s lecture slides.</p>

<p>Processor design companies, also known as hardware companies, have the
flexibility to design processors with vastly different internal architectures
while still supporting exactly the same ISA. These differences in internal
structures can result in the design of processors that are more power-efficient,
faster, or cheaper.</p>

<p>The contrast between two processors supporting the same ISA can be significant.
One processor may be widely adopted and used in numerous systems, while the
other may not be used at all, potentially leading to financial crises within a
company.</p>

<p>In summary, the metrics of two processors can be dramatically opposite, even if
they implement the same ISA.</p>

<h2 id="isa-bad-and-good-news">ISA: Bad and Good News</h2>

<p>Okay, we understand that in order to utilize a processor and write programs that
perform valuable tasks, we have to study the ISA of the processor and program it
accordingly. <strong>But how many ISAs are currently in use?</strong> Can we talk about a
<strong>universal ISA</strong> that all processors support, so we as programmers can learn
one ISA to work with all processors?</p>

<p>The bad news is that there is not just one ISA, I’m afraid. Since the inception
of the first electronic processors, companies began developing their own ISAs.
Therefore, we can’t talk about a universal ISA. However, the good news is that
processors are grouped together in such a way that a group of processors
implements the same ISA. So, the number of ISAs is less than the number of
designed processors.</p>

<p>For example, as programmers, we don’t need to learn a different ISA for each CPU
designed by Intel; fortunately, they share a common ISA base.</p>

<p>The term <strong>architecture</strong> commonly refers to the ISA implemented by a processor.
From a CPU standpoint, common architectures (ISAs) include <strong>ARM (v7, v8, v9…),
x86, x86-64, MIPS, RISC-V,</strong> etc. For example, there are multiple processor design
companies designing ARM CPUs. From a programmer’s viewpoint, instructions
suitable for the ARMv7 ISA, for instance, can be executed on CPUs from both
companies.</p>

<p>Today, many architectures (ISAs) have “plugin” capabilities. While maintaining
the base instructions as a minimum requirement, a vendor may implement
additional instructions. These additional instructions are often referred to as
<strong>extensions.</strong></p>

<p>For example, ARM has SVE (Scalable Vector Extension) to implement fast
vector-based operations. If a program uses these kinds of extensions, these
instructions won’t work on a similar processor lacking that extension.</p>

<h2 id="putting-instructions-into-the-memory">Putting Instructions into The Memory</h2>

<p>Until now, we’ve assumed that instructions executed by the processor are
available in the memory somehow.
<strong>But how do we actually put those instructions into memory?</strong></p>

<p>In today’s computers, when we double-click an application, the instructions for
the application are loaded into memory by the operating system (OS). We don’t
even think about the process of reading instructions from disk and putting them
into memory (RAM) and letting the CPU run the instructions. However, this
process wasn’t as trivial in the old days as it is today.</p>

<p>Many old computers lacked an operating system to read instructions from storage
and load them into memory. Some had operating systems available, but the cost of
operating systems or computers capable of running them was prohibitively high,
so people often didn’t choose those systems. Additionally, storing programs on
paper (punch cards) could be cheaper than storing them on hard disks. Since this
subject is beyond the scope of this post, I won’t go into details, but if you’re
interested, I recommend watching the following video:</p>

<!-- https://github.com/nathancy/jekyll-embed-video -->
<!-- https://yoast.com/how-to-make-youtube-videos-responsive/ -->
<div class="embed-container" style="text-align: center;">
<iframe class="youtube-video lazyload" src="https://www.youtube.com/embed/nwDq4adJwzM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<center><a target="_blank" href="https://www.youtube.com/watch?v=nwDq4adJwzM" rel="nofollow">Video</a></center>

<p>and</p>

<!-- https://github.com/nathancy/jekyll-embed-video -->
<!-- https://yoast.com/how-to-make-youtube-videos-responsive/ -->
<div class="embed-container" style="text-align: center;">
<iframe class="youtube-video lazyload" src="https://www.youtube.com/embed/KG2M4ttzBnY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<center><a target="_blank" href="https://www.youtube.com/watch?v=KG2M4ttzBnY" rel="nofollow">Video</a></center>

<h3 id="altair-8800">Altair 8800</h3>

<p>As an example, I would like to talk about the Altair 8800. According to many
resources, it is considered the first personal (micro)computer. <sup id="fnref:1f"><a href="#fn:1f" class="footnote" rel="footnote" role="doc-noteref">2</a></sup> It
features an Intel 8080 processor and was designed by MITS in 1974. The Altair
8800 played a significant role in the history of Microsoft and Apple.</p>

<p><img data-srcset="/assets/img/24/9-altair.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-altair.jpg" alt="Altair 8800" class="centered lazyload" /></p>

<p class="text-align-center"><a href="https://commons.wikimedia.org/wiki/File:Altair_8800_Computer.jpg">Altair 8800</a></p>

<p>Did you notice something? This computer doesn’t have a keyboard, mouse, or
screen! How are you supposed to program it? Well, you would use the front panel,
which consists of a bunch of switches and LEDs, and perform something called
<strong>Front Panel Programming.</strong></p>

<p><img data-srcset="/assets/img/24/9-altair-panel.jpg" srcset="/assets/lazyload.png" src="/assets/img/24/9-altair-panel.jpg" alt="Altair 8800 Front Panel" class="centered lazyload" /></p>

<p class="text-align-center"><a href="https://commons.wikimedia.org/wiki/File:MITS_Altair_8800_Front_Panel.jpg">Altair 8800 Front Panel</a></p>

<p>By toggling switches, a programmer inputs 0s and 1s into the memory, which are
then read by the processor. After inputting all instructions one by one and
hitting the <code class="language-plaintext highlighter-rouge">RUN</code> button, the processor executes the instructions stored in the
memory. After running all instructions, the results can be read back by toggling
switches and observing LEDs.</p>

<p><strong>This is how a “real programmer” operates a computer!</strong></p>

<!-- https://github.com/nathancy/jekyll-embed-video -->
<!-- https://yoast.com/how-to-make-youtube-videos-responsive/ -->
<div class="embed-container" style="text-align: center;">
<iframe class="youtube-video lazyload" src="https://www.youtube.com/embed/cwEmnfy2BhI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<center><a target="_blank" href="https://www.youtube.com/watch?v=cwEmnfy2BhI" rel="nofollow">Video</a></center>

<p>and</p>

<!-- https://github.com/nathancy/jekyll-embed-video -->
<!-- https://yoast.com/how-to-make-youtube-videos-responsive/ -->
<div class="embed-container" style="text-align: center;">
<iframe class="youtube-video lazyload" src="https://www.youtube.com/embed/7nDcTRqZu8E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>
</div>

<center><a target="_blank" href="https://www.youtube.com/watch?v=7nDcTRqZu8E" rel="nofollow">Video</a></center>

<h2 id="machine-language">Machine Language</h2>

<p>As you can see, we communicate with computers via instructions given in the
corresponding ISA. The instruction set resembles a dictionary for a language
that a processor can understand. This language, which a processor can understand
or “speak,” is called <strong>machine language.</strong> Communicating with a processor, or with
a more technical term, programming it with raw instructions using 0s and 1s, is
called <strong>machine language programming.</strong> Programming a computer with 0s and 1s
directly is the lowest level of programming possible. Machine language is also
known as <strong>machine code.</strong></p>

<p>In programming terminology, we have <strong>low-level</strong> and <strong>high-level</strong> languages.
Low-level languages are closer to the machine than to a human. On the other
hand, high-level languages are more suitable for humans; they resemble natural
human language more than machine language.</p>

<p>Clearly, programs written with 0s and 1s are very close to machines but not to
humans. However, this is what computers or processors understand: 0s and 1s.</p>

<h2 id="assembly-the-first-step-towards-to-programming-languages">Assembly: The First Step Towards to Programming Languages</h2>

<p>Although programming a computer with machine language is a natural way of
programming from the perspective of a processor or computer, understanding a
bunch of 0s and 1s put together isn’t an easy task for a human. A programmer
needs to communicate with colleagues, review code, and so on. However, trying to
understand 0s and 1s and writing programs with them is error-prone and a very
time-consuming task.</p>

<p>So instead of writing programs in 0s and 1s, why can’t we write them in a more
human-readable way and then convert them to 0s and 1s that a processor can
understand? This is exactly how <strong>assembly languages</strong> work!</p>

<blockquote>
  <p>🤔 Trivia: It is believed that the first assembler program was developed for a
British computer known as EDSAC in 1949. <sup id="fnref:2f"><a href="#fn:2f" class="footnote" rel="footnote" role="doc-noteref">3</a></sup></p>
</blockquote>

<p>If you remember, we defined two terms with the PIC16F84 example: <em>mnemonic</em> and
<em>operand.</em> Instead of writing raw 0s and 1s, we can write instructions using
“nicknames” of instructions like <code class="language-plaintext highlighter-rouge">ADD</code>, <code class="language-plaintext highlighter-rouge">SUB</code>, <code class="language-plaintext highlighter-rouge">GOTO</code>, <code class="language-plaintext highlighter-rouge">CLRF</code>, etc. Then, a
computer program called an <strong>assembler</strong> converts those words into 0s and 1s
that a particular CPU can understand. Programmers can interpret words like <code class="language-plaintext highlighter-rouge">ADD</code>
more easily than <code class="language-plaintext highlighter-rouge">000100101</code>, right?</p>

<p>An assembler serves a broader purpose beyond simply translating words into 0s
and 1s. I’ll delve deeper into this concept with an explanation using a specific
assembly program designed for the
<a href="https://www.microchip.com/en-us/product/pic16f628">PIC16F628</a>, a well-known
microcontroller from Microchip.</p>

<pre><code class="language-asm">CNTR1 EQU H'20'
CNTR2 EQU H'21'

  CLRF    PORTB ; Clear PORTB
  BANKSEL TRISB
  CLRF    TRISB
  BANKSEL PORTB
LOOP
  MOVLW h'00'
  MOVWF PORTB
  CALL  DELAY
  MOVLW h'FF'
  MOVWF PORTB
  CALL  DELAY
  GOTO  LOOP
DELAY
  MOVLW h'FF'
  MOVWF CNTR1
LOOP1
  MOVLW h'FF'
  MOVWF CNTR2
LOOP2
  DECFSZ CNTR2, F
  GOTO   LOOP2
  DECFSZ CNTR1, F
  GOTO   LOOP1
  RETURN
  END
</code></pre>

<p>This code doesn’t accomplish anything particularly useful; it simply sets some
registers and then loops through two nested loops. However, the intention here
is to illustrate the structure of an assembly language program.</p>

<p>Most of the lines in the program correspond to a single instruction for the
processor, such as <code class="language-plaintext highlighter-rouge">MOVLW</code>, <code class="language-plaintext highlighter-rouge">MOVWF</code>, and <code class="language-plaintext highlighter-rouge">CALL</code>. Some of them are included for
the sake of simplicity in creating assembly programs.</p>

<p>For example, <code class="language-plaintext highlighter-rouge">CNTR1 EQU H'20'</code> creates a substitution word <code class="language-plaintext highlighter-rouge">CNTR1</code>, which will
be replaced by <code class="language-plaintext highlighter-rouge">0x20</code> when the assembler converts the program into 0s and 1s
that the processor can understand. This functionality is very similar to the
<code class="language-plaintext highlighter-rouge">#define CNTR1 0x20</code> preprocessor directive in C. The same concept applies to
<code class="language-plaintext highlighter-rouge">CNTR2</code>, <code class="language-plaintext highlighter-rouge">PORTB</code>, and <code class="language-plaintext highlighter-rouge">TRISB</code>. This feature of the assembler simplifies
modifications to the program. Instead of writing <code class="language-plaintext highlighter-rouge">0x20</code> everywhere and then
performing a search-and-replace, one can easily change <code class="language-plaintext highlighter-rouge">CNTR1 EQU H'20'</code> to
another value if needed. The definitions for <code class="language-plaintext highlighter-rouge">PORTB</code> and <code class="language-plaintext highlighter-rouge">TRISB</code> are provided by
the vendor so that the user doesn’t need to memorize the actual register
addresses.</p>

<p>Another feature commonly supported by assemblers is the use of labels. <code class="language-plaintext highlighter-rouge">DELAY</code>,
<code class="language-plaintext highlighter-rouge">LOOP</code>, <code class="language-plaintext highlighter-rouge">LOOP1</code>, and <code class="language-plaintext highlighter-rouge">LOOP2</code> are labels. When a label is used with an
instruction like <code class="language-plaintext highlighter-rouge">GOTO</code>, the assembler automatically calculates the address of
the instruction labeled by the label and generates the correct instruction that
directs the processor to start executing that instruction. This simplifies the
programmer’s life, as otherwise, the programmer would need to manually calculate
offsets between instructions.</p>

<p>Many assemblers offer features to fill a memory region with text, typically
represented in ASCII, along with other handy functionalities. However, an
assembly language for a processor strictly adheres to its ISA and machine
language specifications. These additional features simply make a programmer’s
life a bit easier. Since assembly language closely mirrors machine language with
some helpful additions, it is also referred to as <strong>symbolic machine language</strong>
or <strong>symbolic machine code.</strong> While we write programs in a manner similar to
machine language but we use symbols to create them. Ultimately, the assembler
converts the program into machine language, consisting solely of 0s and 1s.</p>

<h3 id="example">Example</h3>

<p>Since assembly languages strictly adhere to the instructions defined in a
particular ISA, <strong>we have different assembly languages for each architecture.</strong>
Let’s write a very simple function for different architectures. The function takes
two inputs and calculates the sum of their squares: <code class="language-plaintext highlighter-rouge">x^2 + y^2</code>.</p>

<p>For <strong>x86-64</strong> architecture:</p>

<pre><code class="language-asm">mov     eax, DWORD PTR [rbp-20]
imul    eax, eax
mov     edx, eax
mov     eax, DWORD PTR [rbp-24]
imul    eax, eax
add     eax, edx
mov     DWORD PTR [rbp-4], eax
</code></pre>

<p>For <strong>RISC-V 64-bits</strong> architecture:</p>

<pre><code class="language-asm">lw      a5,-36(s0)
mulw    a5,a5,a5
sext.w  a4,a5
lw      a5,-40(s0)
mulw    a5,a5,a5
sext.w  a5,a5
addw    a5,a4,a5
sw      a5,-20(s0)
</code></pre>

<p>and for <strong>MIPS</strong>:</p>

<pre><code class="language-asm">lw      $2,24($fp)
nop
mult    $2,$2
mflo    $3
lw      $2,28($fp)
nop
mult    $2,$2
mflo    $2
addu    $2,$3,$2
sw      $2,8($fp)
</code></pre>

<p>As you may easily notice, the same functionality is achieved with different
assembly programs for different architectures. Since their ISAs are different,
the corresponding assembly programs also differ. Although all of them share a
similar pattern and some instructions appear similar, one has to learn each
assembly language for the processors they work on.</p>

<p>A similar issue persists even when working with very similar processors. Let’s
consider another example. In this case, assume we have three variables, x, y,
and z, and we aim to implement z = x + y, where all of them are integers with a
width of 64 bits.</p>

<p>For ARMv7:</p>

<pre><code class="language-asm">ldr     r1, [sp, #16]
ldr     r0, [sp, #20]
ldr     r3, [sp, #8]
ldr     r2, [sp, #12]
adds    r1, r1, r3
adc     r0, r0, r2
str     r1, [sp]
str     r0, [sp, #4]
</code></pre>

<p>For ARMv8:</p>

<pre><code class="language-asm">ldr     x8, [sp, #24]
ldr     x9, [sp, #16]
add     x8, x8, x9
str     x8, [sp, #8]
</code></pre>

<p>The assembly programs for both architectures are very similar; they both contain
almost the same instructions. However, the program for ARMv8 has almost half the
number of instructions compared to the program for ARMv7. This is because ARMv8
is a 64-bit processor architecture, and since the “natural” word length of this
architecture is 64 bits, a single <code class="language-plaintext highlighter-rouge">add</code> instruction is sufficient to sum up two
64-bit variables. On the other hand, ARMv7 is a 32-bit processor architecture
and cannot handle 64-bit variables as easily as ARMv8. Therefore, one has to
split a 64-bit variable into two 32-bit variables and perform multiple
additions.</p>

<hr />

<p>As you can see, programming in assembly language is easier than programming in
machine language. However, one must learn the ISA for each architecture and
consider other factors such as variable sizes and architectural details. Let’s
imagine that you’ve written a fairly large assembly program for the ARMv7
architecture, and one day you need to run the same program on an x86-64
architecture. In that case, you would have to rewrite your program in x86-64
assembly language. Rewriting the same program for a different architecture or
system is known as <strong>porting.</strong> At the assembly language level, porting is not
an easy task because you have to rewrite the entire program again. If you are
supposed to port the same program to five different architectures, good luck!
You will have to rewrite and debug the same program five times using different
assembly languages.</p>

<p>As we conclude this section, it’s important to recognize that even within the
same architecture, there can be multiple assembly language variants. Take x86
assembly, for instance, where two prominent styles exist: <strong>AT&amp;T and Intel.</strong>
<sup id="fnref:3f"><a href="#fn:3f" class="footnote" rel="footnote" role="doc-noteref">4</a></sup> While these styles may appear similar, they differ in the order of
instruction parameters. Nevertheless, despite these variations, they ultimately
produce the same machine code.</p>

<p>This concludes part 1. In part 2, we’ll explore what can be built on top of
assembly language, and I’ll share my personal insights on the existence of
various programming languages. Stay tuned for more!</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:4f">
      <p><a href="https://en.wikipedia.org/wiki/List_of_programming_languages">https://en.wikipedia.org/wiki/List_of_programming_languages</a> <a href="#fnref:4f" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1f">
      <p><a href="https://en.wikipedia.org/wiki/Altair_8800">https://en.wikipedia.org/wiki/Altair_8800</a> <a href="#fnref:1f" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2f">
      <p><a href="https://en.wikipedia.org/wiki/EDSAC">https://en.wikipedia.org/wiki/EDSAC</a> <a href="#fnref:2f" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3f">
      <p><a href="https://en.wikipedia.org/wiki/X86_assembly_language#Syntax">https://en.wikipedia.org/wiki/X86_assembly_language#Syntax</a> <a href="#fnref:3f" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    
    <hr>
    






    
    
    
<!--0-->
        
        
            
                
            
        
    
<!--1-->
        
        
            
                
                    
                    







<ul class="post-list">
<li style="background: #DDEEEE; padding: 10px; border-radius: 10px;">
<h4>🤓 One more?</h4>

<center>
<p>
<a class="post-link" href="/vscode-extension-recommendation.html"><img alt="Teaser" data-srcset="/assets/img/22/11.jpg" srcset="/assets/lazyload.png" src="/assets/img/22/11.jpg" data-srcset="/assets/img/22/11.jpg"  srcset="/assets/lazyload.png" style="border-radius: 10px; height: auto; width: 95%; max-width: 700px;" class="lazyload"></a>
</p>
</center><h3>
<a class="post-link" href="/vscode-extension-recommendation.html">
Recommend Visual Studio Code extensions along with your code

</a>
</h3><h4>VS Code allows us to recommend extensions to developers along with code.</h4></li>
</ul>


  </div>

  
  <div class="revisions" style="border-top: 2px dashed; margin-top: 10px;"><h2 style="padding-top: 10px;">🔄 Updates (Last 10)</h2><ul style="list-style-type: none;">
    
      <li>
        <div class="post-meta"><code>2025-05-09</code> Revert "to ayazar.dev"
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2025-04-02</code> to ayazar.dev
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2025-03-30</code> Revert "to ayazar.dev"
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2025-03-16</code> to ayazar.dev
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2024-10-19</code> revert ayazar.dev
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2024-10-06</code> ayazar.dev
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2024-10-05</code> here
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2024-09-28</code> to ayazar.dev
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2024-09-14</code> revertx3
</div>
      </li>
    
      <li>
        <div class="post-meta"><code>2024-08-30</code> Revert "Revert "ayazar.dev""</div>
      </li>
    
    </ul>
  </div>
  <div class="gicus_comments" style="border-top: 2px dashed; margin-top: 10px;"><h2 style="padding-top: 10px;">💭 Comments</h2>
  <p><small>Comments are provided by <a href="https://giscus.app/">giscus.</a>
    You need to use and authenticate your <a href="https://github.com/">GitHub</a> account to post a comment.
    Comments are stored on the <a href="https://github.com/alperyazar/home/discussions/categories/comments">Github Discussions.</a></small></p><script src="https://giscus.app/client.js"
        data-repo="alperyazar/home"
        data-repo-id="R_kgDOJoQiqA"
        data-category="Comments"
        data-category-id="DIC_kwDOJoQiqM4Cne4h"
        data-mapping="specific"
        data-term='24-9''
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"data-lang="en"data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
<p>🫆 <code>24-9</code></p>
</div><a class="u-url" href="/why-programming-languages-part-1.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Alper Yazar</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Alper Yazar</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/alperyazar"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">alperyazar</span></a></li><li><a href="https://www.linkedin.com/in/alperyazar"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">alperyazar</span></a></li><li><a href="https://mastodon.social/@ayazar"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#mastodon"></use></svg> <span class="username">ayazar</span></a></li><li><a href="https://youtube.com/%40ayazar"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#youtube"></use></svg> <span class="username">@ayazar</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>&quot;Full Stack Electronics&quot; Engineer<br/>© 2011 - 2025<br/><a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></p>
        <p><a href="/disclaimer.html" />Disclaimer</a> <a href="/specimen.html" />Specimen</a> <a href="/" />Contact</a><br><a href='/support.html' />❤️ Destek / Support</a></p>
      </div>
    </div>

  </div>

</footer><!-- Default Statcounter code for Home
https://www.alperyazar.com -->
<script type="text/javascript">
  var sc_project=12712694;
  var sc_invisible=1;
  var sc_security="1c071fc4";
  </script>
  <script type="text/javascript"
  src="https://www.statcounter.com/counter/counter.js"
  async></script>
  <noscript><div class="statcounter"><a title="web statistics"
  href="https://statcounter.com/" target="_blank"><img
  class="statcounter"
  src="https://c.statcounter.com/12712694/0/1c071fc4/1/"
  alt="web statistics"
  referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
  <!-- End of Statcounter Code --></body>

</html>
